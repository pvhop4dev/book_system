package main

import (
	_ "book_system/docs" // docs is generated by Swag CLI, you have to import it.
	"book_system/i18n"
	"book_system/internal/config"
	"book_system/internal/infrastructure"
	restapi "book_system/internal/transport/rest-api"
	"context"
	"fmt"
	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"
	_ "github.com/go-sql-driver/mysql"
	"gorm.io/gorm"
)

func initLogger() {
	handler := &infrastructure.CustomSourceHandler{
		Handler: slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
			Level:     slog.LevelInfo,
			AddSource: false, // Tắt source mặc định
		}),
	}

	// Add attributes to the logger
	logger := slog.New(handler).With(
		slog.String("app", "book_system"),
		slog.String("environment", config.MustGet().Environment),
	)

	// Set the default logger
	slog.SetDefault(logger)
}

func initDB() *gorm.DB {
	db, err := infrastructure.InitDB()
	if err != nil {
		slog.Error("Failed to InitDB", "error", err)
		os.Exit(1)
	}
	sqlDB, _ := db.DB()
	defer func() {
		if err := sqlDB.Close(); err != nil {
			slog.Error("Failed to close database connection", "error", err)
			return
		}
		slog.Info("Database connection closed")
	}()

	// Kiểm tra kết nối
	if err := sqlDB.Ping(); err != nil {
		slog.Error("Failed to ping database", "error", err)
		os.Exit(1)
	}
	slog.Info("Database connected successfully")

	return db
}
func initI18n() {
	i18n.InitI18n([]string{"vi", "en"})
}
func configGin() {
	if config.MustGet().Environment == "production" {
		gin.SetMode(gin.ReleaseMode)
	} else {
		gin.SetMode(gin.DebugMode)
	}
}

func initRedis() {
	infrastructure.InitRedis()
}

// @title Book System API
// @version 1.0
// @description This is a sample server for Book System.
// @termsOfService http://swagger.io/terms/
// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io
// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html
// @host localhost:8080
// @BasePath /api/v1
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
func main() {
	// Tạo context để lắng nghe tín hiệu dừng
	ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer stop()

	initI18n()
	configGin()
	initLogger()
	initRedis()

	db := initDB()

	// Tạo router và cấu hình routes
	router := gin.New()
	apiRouter := restapi.NewRouter(db)
	apiRouter.SetupRoutes(router)

	// Cấu hình server
	serverPort := config.MustGet().Port
	server := &http.Server{
		Addr:    fmt.Sprintf(":%d", serverPort),
		Handler: router,

		ReadTimeout:  15 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	// Channel để bắt lỗi từ server
	serverErr := make(chan error, 1)

	// Chạy server trong goroutine riêng
	go func() {
		slog.Info(fmt.Sprintf("Server is starting on port %d", serverPort))
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			serverErr <- err
		}
	}()

	// Chờ tín hiệu dừng hoặc lỗi từ server
	select {
	case err := <-serverErr:
		slog.Error("Server error", "error", err)
		stop()
	case <-ctx.Done():
		slog.Info("Shutdown signal received")
	}

	slog.Info("Shutting down server gracefully...")

	// Tạo timeout cho việc shutdown
	shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// Dừng nhận request mới và đợi các request đang xử lý
	if err := server.Shutdown(shutdownCtx); err != nil {
		slog.Error("Server forced to shutdown:", "error", err)
	}

	slog.Info("Server exited properly")
}
